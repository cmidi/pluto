// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IpsecTransport.proto

#ifndef PROTOBUF_IpsecTransport_2eproto__INCLUDED
#define PROTOBUF_IpsecTransport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace TT {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IpsecTransport_2eproto();
void protobuf_AssignDesc_IpsecTransport_2eproto();
void protobuf_ShutdownFile_IpsecTransport_2eproto();

class IpsecTunnel;
class IpsecTunnelsContainer;

enum IpsecTunnel_TunnelDirection {
  IpsecTunnel_TunnelDirection_BOTH = 0,
  IpsecTunnel_TunnelDirection_INGRESS = 1,
  IpsecTunnel_TunnelDirection_EGRESS = 2
};
bool IpsecTunnel_TunnelDirection_IsValid(int value);
const IpsecTunnel_TunnelDirection IpsecTunnel_TunnelDirection_TunnelDirection_MIN = IpsecTunnel_TunnelDirection_BOTH;
const IpsecTunnel_TunnelDirection IpsecTunnel_TunnelDirection_TunnelDirection_MAX = IpsecTunnel_TunnelDirection_EGRESS;
const int IpsecTunnel_TunnelDirection_TunnelDirection_ARRAYSIZE = IpsecTunnel_TunnelDirection_TunnelDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* IpsecTunnel_TunnelDirection_descriptor();
inline const ::std::string& IpsecTunnel_TunnelDirection_Name(IpsecTunnel_TunnelDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    IpsecTunnel_TunnelDirection_descriptor(), value);
}
inline bool IpsecTunnel_TunnelDirection_Parse(
    const ::std::string& name, IpsecTunnel_TunnelDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IpsecTunnel_TunnelDirection>(
    IpsecTunnel_TunnelDirection_descriptor(), name, value);
}
// ===================================================================

class IpsecTunnel : public ::google::protobuf::Message {
 public:
  IpsecTunnel();
  virtual ~IpsecTunnel();

  IpsecTunnel(const IpsecTunnel& from);

  inline IpsecTunnel& operator=(const IpsecTunnel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpsecTunnel& default_instance();

  void Swap(IpsecTunnel* other);

  // implements Message ----------------------------------------------

  IpsecTunnel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpsecTunnel& from);
  void MergeFrom(const IpsecTunnel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IpsecTunnel_TunnelDirection TunnelDirection;
  static const TunnelDirection BOTH = IpsecTunnel_TunnelDirection_BOTH;
  static const TunnelDirection INGRESS = IpsecTunnel_TunnelDirection_INGRESS;
  static const TunnelDirection EGRESS = IpsecTunnel_TunnelDirection_EGRESS;
  static inline bool TunnelDirection_IsValid(int value) {
    return IpsecTunnel_TunnelDirection_IsValid(value);
  }
  static const TunnelDirection TunnelDirection_MIN =
    IpsecTunnel_TunnelDirection_TunnelDirection_MIN;
  static const TunnelDirection TunnelDirection_MAX =
    IpsecTunnel_TunnelDirection_TunnelDirection_MAX;
  static const int TunnelDirection_ARRAYSIZE =
    IpsecTunnel_TunnelDirection_TunnelDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TunnelDirection_descriptor() {
    return IpsecTunnel_TunnelDirection_descriptor();
  }
  static inline const ::std::string& TunnelDirection_Name(TunnelDirection value) {
    return IpsecTunnel_TunnelDirection_Name(value);
  }
  static inline bool TunnelDirection_Parse(const ::std::string& name,
      TunnelDirection* value) {
    return IpsecTunnel_TunnelDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string interface = 1;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  inline const ::std::string& interface() const;
  inline void set_interface(const ::std::string& value);
  inline void set_interface(const char* value);
  inline void set_interface(const char* value, size_t size);
  inline ::std::string* mutable_interface();
  inline ::std::string* release_interface();
  inline void set_allocated_interface(::std::string* interface);

  // required string rsa = 2;
  inline bool has_rsa() const;
  inline void clear_rsa();
  static const int kRsaFieldNumber = 2;
  inline const ::std::string& rsa() const;
  inline void set_rsa(const ::std::string& value);
  inline void set_rsa(const char* value);
  inline void set_rsa(const char* value, size_t size);
  inline ::std::string* mutable_rsa();
  inline ::std::string* release_rsa();
  inline void set_allocated_rsa(::std::string* rsa);

  // optional string hmac = 3;
  inline bool has_hmac() const;
  inline void clear_hmac();
  static const int kHmacFieldNumber = 3;
  inline const ::std::string& hmac() const;
  inline void set_hmac(const ::std::string& value);
  inline void set_hmac(const char* value);
  inline void set_hmac(const char* value, size_t size);
  inline ::std::string* mutable_hmac();
  inline ::std::string* release_hmac();
  inline void set_allocated_hmac(::std::string* hmac);

  // optional string key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string algo = 5;
  inline bool has_algo() const;
  inline void clear_algo();
  static const int kAlgoFieldNumber = 5;
  inline const ::std::string& algo() const;
  inline void set_algo(const ::std::string& value);
  inline void set_algo(const char* value);
  inline void set_algo(const char* value, size_t size);
  inline ::std::string* mutable_algo();
  inline ::std::string* release_algo();
  inline void set_allocated_algo(::std::string* algo);

  // optional string tun = 6;
  inline bool has_tun() const;
  inline void clear_tun();
  static const int kTunFieldNumber = 6;
  inline const ::std::string& tun() const;
  inline void set_tun(const ::std::string& value);
  inline void set_tun(const char* value);
  inline void set_tun(const char* value, size_t size);
  inline ::std::string* mutable_tun();
  inline ::std::string* release_tun();
  inline void set_allocated_tun(::std::string* tun);

  // @@protoc_insertion_point(class_scope:TT.IpsecTunnel)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_rsa();
  inline void clear_has_rsa();
  inline void set_has_hmac();
  inline void clear_has_hmac();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_algo();
  inline void clear_has_algo();
  inline void set_has_tun();
  inline void clear_has_tun();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* interface_;
  ::std::string* rsa_;
  ::std::string* hmac_;
  ::std::string* key_;
  ::std::string* algo_;
  ::std::string* tun_;
  friend void  protobuf_AddDesc_IpsecTransport_2eproto();
  friend void protobuf_AssignDesc_IpsecTransport_2eproto();
  friend void protobuf_ShutdownFile_IpsecTransport_2eproto();

  void InitAsDefaultInstance();
  static IpsecTunnel* default_instance_;
};
// -------------------------------------------------------------------

class IpsecTunnelsContainer : public ::google::protobuf::Message {
 public:
  IpsecTunnelsContainer();
  virtual ~IpsecTunnelsContainer();

  IpsecTunnelsContainer(const IpsecTunnelsContainer& from);

  inline IpsecTunnelsContainer& operator=(const IpsecTunnelsContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpsecTunnelsContainer& default_instance();

  void Swap(IpsecTunnelsContainer* other);

  // implements Message ----------------------------------------------

  IpsecTunnelsContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpsecTunnelsContainer& from);
  void MergeFrom(const IpsecTunnelsContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TT.IpsecTunnel ipsec_tunnel = 1;
  inline int ipsec_tunnel_size() const;
  inline void clear_ipsec_tunnel();
  static const int kIpsecTunnelFieldNumber = 1;
  inline const ::TT::IpsecTunnel& ipsec_tunnel(int index) const;
  inline ::TT::IpsecTunnel* mutable_ipsec_tunnel(int index);
  inline ::TT::IpsecTunnel* add_ipsec_tunnel();
  inline const ::google::protobuf::RepeatedPtrField< ::TT::IpsecTunnel >&
      ipsec_tunnel() const;
  inline ::google::protobuf::RepeatedPtrField< ::TT::IpsecTunnel >*
      mutable_ipsec_tunnel();

  // @@protoc_insertion_point(class_scope:TT.IpsecTunnelsContainer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TT::IpsecTunnel > ipsec_tunnel_;
  friend void  protobuf_AddDesc_IpsecTransport_2eproto();
  friend void protobuf_AssignDesc_IpsecTransport_2eproto();
  friend void protobuf_ShutdownFile_IpsecTransport_2eproto();

  void InitAsDefaultInstance();
  static IpsecTunnelsContainer* default_instance_;
};
// ===================================================================


// ===================================================================

// IpsecTunnel

// required string interface = 1;
inline bool IpsecTunnel::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpsecTunnel::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpsecTunnel::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpsecTunnel::clear_interface() {
  if (interface_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_->clear();
  }
  clear_has_interface();
}
inline const ::std::string& IpsecTunnel::interface() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.interface)
  return *interface_;
}
inline void IpsecTunnel::set_interface(const ::std::string& value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.interface)
}
inline void IpsecTunnel::set_interface(const char* value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.interface)
}
inline void IpsecTunnel::set_interface(const char* value, size_t size) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.interface)
}
inline ::std::string* IpsecTunnel::mutable_interface() {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.interface)
  return interface_;
}
inline ::std::string* IpsecTunnel::release_interface() {
  clear_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interface_;
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_interface(::std::string* interface) {
  if (interface_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interface_;
  }
  if (interface) {
    set_has_interface();
    interface_ = interface;
  } else {
    clear_has_interface();
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.interface)
}

// required string rsa = 2;
inline bool IpsecTunnel::has_rsa() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpsecTunnel::set_has_rsa() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpsecTunnel::clear_has_rsa() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpsecTunnel::clear_rsa() {
  if (rsa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_->clear();
  }
  clear_has_rsa();
}
inline const ::std::string& IpsecTunnel::rsa() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.rsa)
  return *rsa_;
}
inline void IpsecTunnel::set_rsa(const ::std::string& value) {
  set_has_rsa();
  if (rsa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_ = new ::std::string;
  }
  rsa_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.rsa)
}
inline void IpsecTunnel::set_rsa(const char* value) {
  set_has_rsa();
  if (rsa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_ = new ::std::string;
  }
  rsa_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.rsa)
}
inline void IpsecTunnel::set_rsa(const char* value, size_t size) {
  set_has_rsa();
  if (rsa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_ = new ::std::string;
  }
  rsa_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.rsa)
}
inline ::std::string* IpsecTunnel::mutable_rsa() {
  set_has_rsa();
  if (rsa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.rsa)
  return rsa_;
}
inline ::std::string* IpsecTunnel::release_rsa() {
  clear_has_rsa();
  if (rsa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsa_;
    rsa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_rsa(::std::string* rsa) {
  if (rsa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsa_;
  }
  if (rsa) {
    set_has_rsa();
    rsa_ = rsa;
  } else {
    clear_has_rsa();
    rsa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.rsa)
}

// optional string hmac = 3;
inline bool IpsecTunnel::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IpsecTunnel::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IpsecTunnel::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IpsecTunnel::clear_hmac() {
  if (hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hmac_->clear();
  }
  clear_has_hmac();
}
inline const ::std::string& IpsecTunnel::hmac() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.hmac)
  return *hmac_;
}
inline void IpsecTunnel::set_hmac(const ::std::string& value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.hmac)
}
inline void IpsecTunnel::set_hmac(const char* value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.hmac)
}
inline void IpsecTunnel::set_hmac(const char* value, size_t size) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.hmac)
}
inline ::std::string* IpsecTunnel::mutable_hmac() {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.hmac)
  return hmac_;
}
inline ::std::string* IpsecTunnel::release_hmac() {
  clear_has_hmac();
  if (hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hmac_;
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_hmac(::std::string* hmac) {
  if (hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hmac_;
  }
  if (hmac) {
    set_has_hmac();
    hmac_ = hmac;
  } else {
    clear_has_hmac();
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.hmac)
}

// optional string key = 4;
inline bool IpsecTunnel::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IpsecTunnel::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IpsecTunnel::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IpsecTunnel::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& IpsecTunnel::key() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.key)
  return *key_;
}
inline void IpsecTunnel::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.key)
}
inline void IpsecTunnel::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.key)
}
inline void IpsecTunnel::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.key)
}
inline ::std::string* IpsecTunnel::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.key)
  return key_;
}
inline ::std::string* IpsecTunnel::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.key)
}

// optional string algo = 5;
inline bool IpsecTunnel::has_algo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IpsecTunnel::set_has_algo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IpsecTunnel::clear_has_algo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IpsecTunnel::clear_algo() {
  if (algo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    algo_->clear();
  }
  clear_has_algo();
}
inline const ::std::string& IpsecTunnel::algo() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.algo)
  return *algo_;
}
inline void IpsecTunnel::set_algo(const ::std::string& value) {
  set_has_algo();
  if (algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    algo_ = new ::std::string;
  }
  algo_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.algo)
}
inline void IpsecTunnel::set_algo(const char* value) {
  set_has_algo();
  if (algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    algo_ = new ::std::string;
  }
  algo_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.algo)
}
inline void IpsecTunnel::set_algo(const char* value, size_t size) {
  set_has_algo();
  if (algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    algo_ = new ::std::string;
  }
  algo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.algo)
}
inline ::std::string* IpsecTunnel::mutable_algo() {
  set_has_algo();
  if (algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    algo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.algo)
  return algo_;
}
inline ::std::string* IpsecTunnel::release_algo() {
  clear_has_algo();
  if (algo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = algo_;
    algo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_algo(::std::string* algo) {
  if (algo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete algo_;
  }
  if (algo) {
    set_has_algo();
    algo_ = algo;
  } else {
    clear_has_algo();
    algo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.algo)
}

// optional string tun = 6;
inline bool IpsecTunnel::has_tun() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IpsecTunnel::set_has_tun() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IpsecTunnel::clear_has_tun() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IpsecTunnel::clear_tun() {
  if (tun_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tun_->clear();
  }
  clear_has_tun();
}
inline const ::std::string& IpsecTunnel::tun() const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnel.tun)
  return *tun_;
}
inline void IpsecTunnel::set_tun(const ::std::string& value) {
  set_has_tun();
  if (tun_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tun_ = new ::std::string;
  }
  tun_->assign(value);
  // @@protoc_insertion_point(field_set:TT.IpsecTunnel.tun)
}
inline void IpsecTunnel::set_tun(const char* value) {
  set_has_tun();
  if (tun_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tun_ = new ::std::string;
  }
  tun_->assign(value);
  // @@protoc_insertion_point(field_set_char:TT.IpsecTunnel.tun)
}
inline void IpsecTunnel::set_tun(const char* value, size_t size) {
  set_has_tun();
  if (tun_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tun_ = new ::std::string;
  }
  tun_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TT.IpsecTunnel.tun)
}
inline ::std::string* IpsecTunnel::mutable_tun() {
  set_has_tun();
  if (tun_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tun_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnel.tun)
  return tun_;
}
inline ::std::string* IpsecTunnel::release_tun() {
  clear_has_tun();
  if (tun_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tun_;
    tun_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpsecTunnel::set_allocated_tun(::std::string* tun) {
  if (tun_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tun_;
  }
  if (tun) {
    set_has_tun();
    tun_ = tun;
  } else {
    clear_has_tun();
    tun_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TT.IpsecTunnel.tun)
}

// -------------------------------------------------------------------

// IpsecTunnelsContainer

// repeated .TT.IpsecTunnel ipsec_tunnel = 1;
inline int IpsecTunnelsContainer::ipsec_tunnel_size() const {
  return ipsec_tunnel_.size();
}
inline void IpsecTunnelsContainer::clear_ipsec_tunnel() {
  ipsec_tunnel_.Clear();
}
inline const ::TT::IpsecTunnel& IpsecTunnelsContainer::ipsec_tunnel(int index) const {
  // @@protoc_insertion_point(field_get:TT.IpsecTunnelsContainer.ipsec_tunnel)
  return ipsec_tunnel_.Get(index);
}
inline ::TT::IpsecTunnel* IpsecTunnelsContainer::mutable_ipsec_tunnel(int index) {
  // @@protoc_insertion_point(field_mutable:TT.IpsecTunnelsContainer.ipsec_tunnel)
  return ipsec_tunnel_.Mutable(index);
}
inline ::TT::IpsecTunnel* IpsecTunnelsContainer::add_ipsec_tunnel() {
  // @@protoc_insertion_point(field_add:TT.IpsecTunnelsContainer.ipsec_tunnel)
  return ipsec_tunnel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TT::IpsecTunnel >&
IpsecTunnelsContainer::ipsec_tunnel() const {
  // @@protoc_insertion_point(field_list:TT.IpsecTunnelsContainer.ipsec_tunnel)
  return ipsec_tunnel_;
}
inline ::google::protobuf::RepeatedPtrField< ::TT::IpsecTunnel >*
IpsecTunnelsContainer::mutable_ipsec_tunnel() {
  // @@protoc_insertion_point(field_mutable_list:TT.IpsecTunnelsContainer.ipsec_tunnel)
  return &ipsec_tunnel_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TT

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TT::IpsecTunnel_TunnelDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TT::IpsecTunnel_TunnelDirection>() {
  return ::TT::IpsecTunnel_TunnelDirection_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IpsecTransport_2eproto__INCLUDED
